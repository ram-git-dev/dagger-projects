name: Chaos Engineering Test

on:
  workflow_dispatch:
    inputs:
      namespace:
        description: 'Target namespace'
        required: true
        default: 'default'
        type: string
      deployment:
        description: 'Target deployment name'
        required: true
        default: 'sample-app'
        type: string
      chaos_type:
        description: 'Type of chaos to inject'
        required: true
        type: choice
        options:
          - pod-delete
          - pod-network-latency
          - pod-cpu-hog
          - pod-memory-hog
        default: 'pod-delete'
      chaos_duration:
        description: 'Chaos duration in seconds'
        required: true
        default: '60'
        type: string
      load_test_duration:
        description: 'Load test duration (e.g., 5m, 300s)'
        required: true
        default: '5m'
        type: string
      load_test_vus:
        description: 'Number of virtual users (concurrent requests)'
        required: true
        default: '10'
        type: string
      cleanup_after:
        description: 'Clean up operators after test?'
        required: true
        type: boolean
        default: true

jobs:
  chaos-test:
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Prepare kubeconfig for Dagger
        id: prepare-kube
        run: |
          set -euo pipefail
          mkdir -p $HOME/.kube

          # Option A: decode an embedded kubeconfig secret (preferred)
          if [ -n "${{ secrets.KUBECONFIG_BASE64 }}" ]; then
            echo "${{ secrets.KUBECONFIG_BASE64 }}" | base64 -d > $HOME/.kube/config
            chmod 600 $HOME/.kube/config
            echo "decoded"
          else
            # Option B: build embedded kubeconfig from host files (requires kubectl on runner)
            if ! command -v kubectl >/dev/null 2>&1; then
              echo "kubectl is required on the runner to build an embedded kubeconfig" >&2
              exit 1
            fi
            kubectl config view --raw --flatten > /tmp/kube_embedded.yaml

            # Detect a host IP reachable from containers and patch server if needed
            HOST_IP=$(hostname -I | awk '{print $1}')
            [ -z "$HOST_IP" ] && HOST_IP=$(cat /etc/resolv.conf | awk '/nameserver/ {print $2; exit}' || true)

            if [ -n "$HOST_IP" ]; then
              perl -i -pe 's{(https?://)(?:[^:/]*)?(:[0-9]+)}{$1 . ENV{"HOST_IP"} . $3}ge' /tmp/kube_embedded.yaml
            fi

            mv /tmp/kube_embedded.yaml $HOME/.kube/config
            chmod 600 $HOME/.kube/config
            echo "built"
          fi

          # Fix potential inline YAML corruption where 'name:' landed on same line as 'server:'
          # Ensures valid YAML like: server: https://host:port\n  name: minikube
          perl -0777 -i -pe 's{(server:\s*\S+)\s+name:}{\1\n  name:}g' $HOME/.kube/config || true

          # Diagnostics for logs
          echo "--- kubeconfig server lines ---"
          grep -n "server:" $HOME/.kube/config || true
          echo "--- kubeconfig head ---"
          sed -n '1,40p' $HOME/.kube/config

      - name: Install Dagger CLI
        run: |
          mkdir -p $HOME/.dagger/bin
          curl -L https://dl.dagger.io/dagger/install.sh | BIN_DIR=$HOME/.dagger/bin sh
          export PATH=$HOME/.dagger/bin:$PATH
          dagger version

      - name: Test kubectl (sanity check)
        run: |
          # quick checks to fail early if kubeconfig is invalid or server unreachable
          kubectl --kubeconfig=$HOME/.kube/config cluster-info || true
          kubectl --kubeconfig=$HOME/.kube/config get nodes || true

      - name: Run Dagger Chaos Pipeline
        working-directory: chaos-toolkit/dagger
        env:
          KUBECONFIG: ${{ env.HOME }}/.kube/config
        run: |
          go mod download
          dagger call chaos-test \
            --namespace="${{ inputs.namespace }}" \
            --deployment="${{ inputs.deployment }}" \
            --kubeconfig-dir="$HOME/.kube" \
            --cleanup=${{ inputs.cleanup_after }}

      - name: Upload Chaos Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: chaos-report-${{ github.run_number }}
          path: |
            chaos-toolkit/output/*.html
            chaos-toolkit/output/*.json
          retention-days: 30

      - name: Comment PR with Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('chaos-toolkit/output/summary.json', 'utf8');
            const data = JSON.parse(summary);

            const comment = `## üß™ Chaos Test Results

            **Target:** \`${{ inputs.deployment }}\` in \`${{ inputs.namespace }}\`
            **Chaos Type:** ${{ inputs.chaos_type }}
            **Duration:** ${{ inputs.chaos_duration }}s

            ### Results
            - **Status:** ${data.passed ? '‚úÖ PASSED' : '‚ùå FAILED'}
            - **Error Rate:** ${data.errorRate}%
            - **P99 Latency:** ${data.p99Latency}ms
            - **Recovery Time:** ${data.recoveryTime}s

            üìä [Download Full Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
